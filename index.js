// Generated by CoffeeScript 1.7.1
(function() {
  var Gassetic, clean, concat, frep, fs, gulp, gutil, livereload, path, q, tap;

  concat = require("gulp-concat");

  clean = require('gulp-clean');

  frep = require("gulp-frep");

  fs = require("fs");

  gulp = require("gulp");

  gutil = require("gulp-util");

  livereload = require("gulp-livereload");

  path = require("path");

  tap = require('gulp-tap');

  q = require('q');

  module.exports = Gassetic = (function() {
    function Gassetic(config, env, modules, log) {
      this.config = config;
      this.env = env;
      this.modules = modules;
      this.log = log != null ? log : true;
      this.validateConfig();
    }


    /*
    		self explanatory
     */

    Gassetic.prototype.validateConfig = function() {
      var file, key, src, task, what, _i, _len, _ref, _results;
      if (this.getMimetypes() == null) {
        throw 'missing mimetypes in config';
      }
      if (this.getDefaultTypes() == null) {
        throw 'missing default task in config';
      }
      _results = [];
      for (key in this.getMimetypes()) {
        if (this.getMimetypes()[key][this.env] == null) {
          throw 'missing environment ' + this.env + ' in ' + key + ' mimetype';
        }
        if (this.getMimetypes()[key][this.env].tasks == null) {
          throw 'missing task list for ' + this.env + ' environment in ' + key + ' mimetype (it can be empty array but must be defined)';
        }
        _ref = this.getMimetypes()[key][this.env].tasks;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          task = _ref[_i];
          if (!task.name) {
            throw 'invalid task "' + task.toString() + '" for ' + key + ' in ' + this.env + ' environment, the structure must be like is {name: coffee, args: { bare: true }}';
          }
        }
        if (this.getMimetypes()[key].files == null) {
          throw 'missing file list for ' + key + ' mimetype';
        }
        if (this.getMimetypes()[key][this.env].outputFolder == null) {
          throw 'missing outputFolder path in ' + key + ' ' + this.env;
        }
        src = this.getSourceFilesForType(key);
        what = Object.prototype.toString;
        if (what.call(src) !== '[object Object]') {
          throw 'wrong file list for ' + key + ' mimetype';
        }
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (file in src) {
            if (what.call(file) !== '[object String]') {
              throw 'invalid file "' + file + '" for ' + key + ' in ' + this.env + ' environment';
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };


    /*
    		@return {Object} mimetypes
     */

    Gassetic.prototype.getMimetypes = function() {
      return this.config.mimetypes;
    };


    /*
    		@return {Array} default tasks
     */

    Gassetic.prototype.getDefaultTypes = function() {
      return this.config["default"];
    };


    /*
     */

    Gassetic.prototype.getSourceFilesForType = function(type) {
      return this.getMimetypes()[type].files;
    };

    Gassetic.prototype.clean = function() {
      var files, result, type;
      result = q.defer();
      files = [];
      for (type in this.getMimetypes()) {
        this.getDestinationPathsForType(type).map(function(f) {
          return files.push(f);
        });
      }
      gulp.src(files, {
        read: false
      }).pipe(clean({
        force: true
      })).on('end', function() {
        return result.resolve(true);
      });
      return result.promise;
    };

    Gassetic.prototype.getDestinationPathsForType = function(type) {
      var key, paths, value, _ref;
      paths = [];
      _ref = this.getMimetypes()[type].files;
      for (key in _ref) {
        value = _ref[key];
        paths.push(path.join(this.getMimetypes()[type][this.env].outputFolder, key));
      }
      return paths;
    };


    /*
    		Builds all
     */

    Gassetic.prototype.build = function() {
      var done, finalPromise, promises, type, _i, _len, _ref;
      this.replaces = {};
      this.watchFiles = [];
      finalPromise = q.defer();
      promises = [];
      _ref = this.getDefaultTypes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        promises.push(this.buildType(type));
      }
      done = q.all(promises);
      done.then((function(_this) {
        return function() {
          return _this.replaceInFiles(_this.replaces).then(function() {
            return finalPromise.resolve(true);
          });
        };
      })(this));
      return finalPromise.promise;
    };

    Gassetic.prototype.cwd = function() {
      return process.cwd();
    };


    /*
    		Builds one type defined in config
     */

    Gassetic.prototype.buildType = function(type) {
      var all, buildOne, deps, next, result;
      buildOne = (function(_this) {
        return function(type) {
          var all, destFilename, tasks;
          _this.replaces[type] = {};
          all = [];
          tasks = _this.getMimetypes()[type][_this.env].tasks;
          if (_this.log) {
            gutil.log('Processing:', gutil.colors.magenta(type), 'with', gutil.colors.gray((tasks.map(function(t) {
              return t.name + '(' + (t.args ? JSON.stringify(t.args) : '') + ')';
            })).join(', ')));
          }
          for (destFilename in _this.getSourceFilesForType(type)) {
            all.push(_this.buildFiles(type, destFilename));
          }
          return q.all(all);
        };
      })(this);
      result = q.defer();
      deps = this.findDependentTypes(type);
      if (deps.length > 0) {
        all = [];
        while (deps.length > 0) {
          next = deps.shift();
          all.push(this.buildType(next));
        }
        q.all(all).then((function(_this) {
          return function() {
            return buildOne.call(_this, type).then(function() {
              return result.resolve(true);
            });
          };
        })(this));
      } else {
        buildOne.call(this, type).then(function() {
          return result.resolve(true);
        });
      }
      return result.promise;
    };


    /*
     */

    Gassetic.prototype.buildFiles = function(type, destinationFilenameConfigKey) {
      var destination, pipe, result, sourceFiles, tasks;
      this.replaces[type][destinationFilenameConfigKey] = [];
      result = q.defer();
      tasks = this.getMimetypes()[type][this.env].tasks;
      if (this.log) {
        gutil.log(' -', gutil.colors.cyan(destinationFilenameConfigKey));
      }
      sourceFiles = this.getMimetypes()[type].files[destinationFilenameConfigKey];
      destination = path.join(this.getMimetypes()[type][this.env].outputFolder, destinationFilenameConfigKey);
      pipe = gulp.src(sourceFiles);
      tasks.map((function(_this) {
        return function(t) {
          var _ref, _ref1;
          if (t.args != null) {
            return pipe = pipe.pipe((_ref = _this.modules)[t.name].apply(_ref, [_this.replaceArgs(t.args, destinationFilenameConfigKey)]));
          } else if (t.callback != null) {
            return pipe = pipe.pipe((_ref1 = _this.modules)[t.name].apply(_ref1, [_this.modules[t.callback]]));
          } else {
            return pipe = pipe.pipe(_this.modules[t.name].call(_this));
          }
        };
      })(this));
      pipe = pipe.pipe(gulp.dest(destination)).pipe(tap((function(_this) {
        return function(f) {
          var webPath;
          if (_this.getMimetypes()[type][_this.env].webPath) {
            webPath = f.path.substring((path.join(_this.cwd(), _this.getMimetypes()[type][_this.env].outputFolder)).length + 1);
            webPath = path.join(_this.getMimetypes()[type][_this.env].webPath, webPath);
            _this.replaces[type][destinationFilenameConfigKey].push(webPath);
          }
          return _this.watchFiles.push(f.path);
        };
      })(this))).on('end', function() {
        return result.resolve(true);
      });
      return result.promise;
    };

    Gassetic.prototype.replaceArgs = function(args, filename) {
      var string;
      string = JSON.stringify(args);
      string = string.replace('%filename%', filename);
      return JSON.parse(string);
    };

    Gassetic.prototype.replaceInFiles = function(replacements, callback) {
      var allfiles, filename, one, progress, regexs, scripts, type, _i, _len, _ref;
      regexs = [];
      for (type in replacements) {
        for (one in replacements[type]) {
          scripts = '\n';
          _ref = replacements[type][one];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            filename = _ref[_i];
            scripts += this.buildScriptString(type, filename) + '\n';
          }
          regexs.push({
            pattern: new RegExp('<!-- ' + this.env + ':' + one + " -->([\\s\\S]*?)<!-- endbuild -->", "ig"),
            replacement: "<!-- " + this.env + ":" + one + " -->" + scripts + "<!-- endbuild -->"
          });
        }
      }
      allfiles = [];
      progress = [];
      gulp.src(this.config.replacementPaths, {
        read: false
      }).pipe(tap(function(file) {
        return allfiles.push(file.path);
      })).on('end', function() {
        var file, result, _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = allfiles.length; _j < _len1; _j++) {
          file = allfiles[_j];
          result = q.defer();
          progress.push(result.promise);
          _results.push((function(file, deferred) {
            return gulp.src(file).pipe(frep(regexs)).pipe(gulp.dest(path.dirname(file))).on('end', function() {
              return deferred.resolve(true);
            });
          })(file, result));
        }
        return _results;
      });
      return q.all(progress);
    };

    Gassetic.prototype.buildScriptString = function(type, fileWebPath) {
      var ext, str;
      fileWebPath = fileWebPath.replace(/\\/g, '/');
      if (this.getMimetypes()[type][this.env].htmlTag != null) {
        return this.getMimetypes()[type][this.env].htmlTag.replace(/%path%/g, fileWebPath);
      } else {
        ext = path.extname(fileWebPath);
        switch (ext) {
          case ".css":
            str = "<link rel=\"stylesheet\" href=\"" + fileWebPath + "\" />";
            break;
          case ".js":
            str = "<script src=\"" + fileWebPath + "\"></script>";
            break;
          default:
            str = '<!-- extension not supported -->';
        }
        return str;
      }
    };


    /*
    		Finds dependent types for type that needs to be run first
    		@param {string} type
    		@param {boolean} recursive
    		@return {Array} dependency types
     */

    Gassetic.prototype.findDependentTypes = function(type, recursive) {
      var d, deps, _i, _len, _ref;
      deps = [];
      if (this.config.mimetypes[type].deps != null) {
        _ref = this.config.mimetypes[type].deps;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          d = _ref[_i];
          deps.push(d);
          if (recursive) {
            deps = deps.concat(this.findDependentTypes(d));
          }
        }
      }
      return deps;
    };

    Gassetic.prototype.watch = function() {
      var d, destinationFile, server, sources, toWatch, type, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      server = livereload();
      toWatch = [];
      _ref = this.getDefaultTypes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        toWatch.push(type);
        _ref1 = this.findDependentTypes(type, true);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          d = _ref1[_j];
          if (toWatch.indexOf(d) === -1) {
            toWatch.push(d);
          }
        }
      }
      for (_k = 0, _len2 = toWatch.length; _k < _len2; _k++) {
        type = toWatch[_k];
        if (this.getMimetypes()[type].watch != null) {
          this.watchSources(this.getMimetypes()[type].watch, type);
        } else {
          for (destinationFile in this.getMimetypes()[type].files) {
            sources = this.getMimetypes()[type].files[destinationFile];
            this.watchSources(sources, type, destinationFile);
          }
        }
      }
      return gulp.watch(this.watchFiles).on('change', (function(_this) {
        return function(e) {
          if (_this.log) {
            gutil.log(gutil.colors.yellow(new Date()));
          }
          if (_this.log) {
            gutil.log(gutil.colors.blue(e.path));
          }
          return server.changed(e.path);
        };
      })(this));
    };

    Gassetic.prototype.watchSources = function(sources, type, destinationFile) {
      if (destinationFile == null) {
        destinationFile = '*';
      }
      if (this.log) {
        gutil.log('Watching', gutil.colors.cyan(sources.length), gutil.colors.magenta(type), 'paths for', gutil.colors.green(destinationFile), '...');
      }
      return gulp.watch(sources).on('change', (function(_this) {
        return function(e) {
          var destFiles, f, _i, _len, _results;
          if (destinationFile !== '*') {
            destFiles = [destinationFile];
          } else {
            destFiles = [];
            for (f in _this.getMimetypes()[type].files) {
              destFiles.push(f);
            }
          }
          _results = [];
          for (_i = 0, _len = destFiles.length; _i < _len; _i++) {
            f = destFiles[_i];
            _results.push(_this.buildFiles(type, f));
          }
          return _results;
        };
      })(this));
    };

    return Gassetic;

  })();

}).call(this);
